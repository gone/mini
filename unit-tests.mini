# feature tests: variables
(assert "Evaluating undefined variable throws exception"
        (throws? undefined-identifier "UndefinedIdentifierError"))

# `=` tests
(assert "`=` returns true for equal numbers" (= 0 0))
(assert "`=` returns false for non-equal numbers" (not (= 0 1)))
(assert "`=` returns true for equal strings" (= "Hello, world" "Hello, world"))
(assert "`=` returns false for non-equal strings" (not (= "Hello, world" "Goodnight, moon")))
(assert "`=` returns true for equal true values" (= true true))
(assert "`=` returns true for equal false values" (= false false))
(assert "`=` returns true for nils" (= nil nil))
(assert "`=` returns true for equal keywords" (= :keyword :keyword))
(assert "`=` returns false for non-equal keywords" (not (= :keyword :not-the-same)))
(assert "`=` returns false for keyword-to-string comparison (string first)"
        (not (= :keyword ":keyword")))
(assert "`=` returns false for keyword-to-string comparison (keyword first)"
        (not (= ":keyword" :keyword)))

# `+` tests
(assert "`+` adds" (= (+ 1 2) 3))

# `-` tests
(assert "`-` subtracts" (= (- 3 2) 1))

# `*` tests
(assert "`*` divides" (= (* 2 3) 6))

# `/` tests
(assert "`/` divides evenly" (= (/ 6 3) 2))
(assert "`/` divides fractionally" (= (/ 7 2) 3.5))

# `//` tests
(assert "`//` divides evenly" (= (// 6 3) 2))
(assert "`//` divides integrally" (= (// 7 2) 3))

# `and` tests
(assert "`and` returns false for both false" (not (and false false)))
(assert "`and` returns false for left false and right true" (not (and false true)))
(assert "`and` returns false for left true and right false" (not (and true false)))
(assert "`and` returns true for both true" (and true true))
(assert "`and` doesn't evalueate second argument if first is false" (not (and false (/ 1 0))))

# `assert` tests
(assert "`assert` executes without exception for true assertion" true)
(assert "`assert` returns nil for true assertion" (= (assert true) nil))
(assert "`assert` throws AssertionError for false assertion"
        (throws? (assert false) "AssertionError"))
(assert "`assert` throws TypeError for non-boolean assertion"
        (throws? (assert 1) "TypeError"))
(assert "`assert` can take multiple arguments" false true)
(assert "`assert` executes assertion in a nested scope"
        (assert "define identifier in nested scope"
                (define identifier-in-nested-scope true)
                true)
        (not (defined? identifier-in-nested-scope)))

# `define` tests
(assert "`define` adds identifier to environment"
        (define previously-undefined-identifier true)
        previously-undefined-identifier)
(assert "`define` throws exception for already-defined variable"
        (define already-defined-identifier :value)
        (throws? (define already-defined-identifier :another-value) "AlreadyDefinedError"))

# `defined?` tests
(assert "`defined?` returns true for defined identifier" (defined? assert))
(assert "`defined?` returns false for undefined identifier"
        (not (defined? undefined-identifier)))

# `if` tests
(assert "`if` returns second argument for true condition"
        (if true true false))
(assert "`if` returns third argument for false condition"
        (if false false true))
(assert "`if` doesn't execute third argument for true condition"
        (if true true undefined-identifier))
(assert "`if` doesn't execute second argument for false condition"
        (if false undefined-identifier true))

# `mapping` tests
(assert "`mapping` creates a callable mapping"
        ((mapping :keyword true) :keyword))

# `not` tests
(assert "`not` returns false for true" (= (not true) false))
(assert "`not` returns true for false" (= (not false) true))
(assert "`not` throws TypeError for non-boolean argument"
        (throws? (not 1) "TypeError"))

# `operative` tests
(assert "`operative` creates callable operative"
        ((operative () env true)))
(assert "`operative` receives the environment"
        (define receives-environment (operative () env (evaluate (quote true-identifier) env)))
        (define true-identifier true)
        (receives-environment))
(assert "`operative` receives arguments"
        ((operative (arg) env (evaluate arg env)) true))
(assert "`operative` executes in its own environment"
        ((operative () env
                    (define should-not-be-defined false)))
        (not (defined? should-not-be-defined)))
(assert "`operative` doesn't evaluate its arguments"
        ((operative (arg) env true) (/ 1 0)))

# `or` tests
(assert "`or` returns false for both false" (not (or false false)))
(assert "`or` returns true for left false and right true" (or false true))
(assert "`or` returns true for left true and right false" (or true false))
(assert "`or` returns true for both true" (or true true))
(assert "`or` doesn't evalueate second argument if first is true" (or true (/ 1 0)))

# `throws?` tests
(assert "`throws?` returns false when no exception is thrown"
        (not (throws? (assert true) "AssertionError")))
(assert "`throws?` returns true when the correct exception is thrown"
        (throws? (assert false) "AssertionError"))
(assert "`throws?` returns false when the wrong exception is thrown"
        (not (throws? (assert false) "TypeError")))
